# JUnit in Sping Boot

Topics - 
1. What is Unit Testing ..?
2. Why Unit Testing is important ..?
3. What is the use of Mokito (@Mock) ..?
4. How to write the Test Codes in Java Spring ..?
5. @BeforeAll, @BeforeEach, @AfterEach, @AfterAll
6. How to verify how many times any method has been called using Mokito ..?
7. How to perform Nothing through Mockito when some method is invoked ..?
8. How to consume the private methods of any service on Testing since we can't directly call them ..?





## 1. What is Unit Testing ..?

A Unit test is the way to test small piece of code, such as individual methods or classes to ensure they work as expected.









## 2. Why Unit Testing is important ..?

- **Fast Feedback** - Quick to run and imediately tells you what is broken.

- **Early Bug Detection** - Catch Bug at method level before they propogate.

- **Easier to Maintain** - To ensure future changes wouldn't afftect the existing functionality.






## 3. What is the use of Mokito (@Mock) ..?

- While performing the Tests, sometime it is difficult to create the object of any class but at the same time we need that particular object as it needs to be used on some of the Test cases.

- Here, **@Mock** will help to create a sample of the object or mock the object creation.


- After creating the mock object, we needs Inject the mocked object.

- **@InjectMocks** is used to Inject the mock object of one class to another.




## 4. How to write the Test Codes in Java Spring ..?

Apart from main folder, there is another folder called test on which we can define our Test cases.


For Example, suppose we have a service file where some method is define like below - 

```
@Component
public class ProductService {

    private final ProductRepository prodRepo ;

    @Autowired
    public ProdutService (ProductRepository prodRepository){
        this.prodRepo = prodRepository ;
    }


    public Product addProduct ( Product product ) {
        log.info("adding product in DB" );

        Product saveProduct = prodRepo.save(product) ;

        log.info("Successfully added the product);

        return saveProduct ;
    }

}
```


And we want to write its test case.
Hence the Test would look like below - 

```
@ExtendWith(MockitoExtension.class)
public class productServiceTest {
    
    @Mock 
    ProductRepository prodRepository ;
    
    @InjectMocks
    ProductService productService ;

    @Test
    void testAddProduct () {
        Product product = new Product () ;

        product.setID(34);
        product.setName("something");

        //  What it is doing is when we perform CREATE operation on DB, instead of actually performing the Create operation, it will try to mock it.

        Mockito.when(productRepository.save(product)).thenReturns(product);

        Product addProduct = productService.addProduct( product ) ;

        Assertions.assertEquals( product.getId(), addProduct.getId() );
    }

    
}
```






## 5. @BeforeAll, @BeforeEach, @AfterEach, @AfterAll

-   @BeforeAll, @BeforeEach, @AfterEach, @AfterAll annotations are used at the method level to execute that particular method accordingly.

- It is moslty used with methods which are doing some configuration or data setup.


## 6. How to verify how many times any method has been called using Mokito ..?

- Suppose we wants to check how many times the productRepository has been called and its deleteById method has been called.
- We are expecting it should be called once (1 time).

```
mockito.verify( productRepository, times(wantedNumberOfInvocations : 1)).deleteById(1);
```






## 7. How to perform Nothing through Mockito when some method is invoked ..?


```
mockito.doNothing().when(delete)
```


## 8. How to consume the private methods of any service on Testing since we can't directly call them ..?

Suppose we have a method like below - 

```
private Boolean validateProductName ( String name ) {
    return name != null && !name.isEmpty() ;
}
```

Then our Test case would look like - 

```
@Test
void testPrivateMethod_validateProductName () throws NoSuchMethodException {
    Method validateProductName = ProductService.class.getDeclaredMethod(name : "validateProductName", String.class);

    validateProductName.setAccessible(true);

    Boolean book = (boolean) validateProductName.invoke(productService, ...args : "Book" ) ;
}
```