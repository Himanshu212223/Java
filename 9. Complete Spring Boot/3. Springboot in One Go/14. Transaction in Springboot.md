# Spring Transactions and @Transactional Annotation

1. What Problem does Transactions solves ..?
2. Overview of how it works ..?
3. How to use @Transactional Annotation ..?
4. What is Transaction Managers ..?
5. What is Transaction Propogation ?
6. Types of Transaction Propogation



## 1. Problem - 
There could be inconsistency in data when multiple try to hit or consume the same resource.


### Solution -

- Transactional helps here and solves the problem.
- It helps to  achieve **ACID** property.

### A (Atomicity)

- Ensure all operations in transaction are completed successfully.
- If any operation fails, then entire transaction is rolled back.

### C (Consistency)

- Ensure that the DB state is same before and after the transaction.

### I (Isolation)

- Ensure that if multiple transactions are running in parallel, they do not interfere with each other.

### D (Durability)

- Ensure that committed transaction will never be lost and despite of system failures.


## 2. Overview of how it works ..?

```
BEGIN_TRANSACTION
    - Debit From A
    - Credit from B
    If All Success
        COMMIT ;
    Else :
        RollBack ;
END_TRANSACTION
```




## 3. How to use @Transactional Annotation ..?

- We can use this Annotation at **method level or class level** and can be used in **Service Layer**.

- It is **not useful with Private methods**.

- Generally **@EnableTransactionManagement** is useful to enable the use of Transaction but it is not needed to use it as Spring Boot Auto configures these things.


## 4. What is Transaction Managers ..?

- It is responsible for managing, receiving the Transactions, commiting the Transaction or Rolling back of Transaction.

- It is a parent Interface.

![Transaction](./Screenshots/Transactions.png)


### 5. What is Transaction Propogation ?

It refers to how the Transaction behave when a method Annotated with `@Transactional` is called by another method that may or may not have any active transaction.


### 6. Types of Transaction Propogation - 

#### REQUIRED (default propogation)

```
@Transactional (propogation = Propogation.REQUIRED)
```

- If any Transaction is already going on, then it will join the same flow to commit the changes.

- If no any transaction is already going, then it will create a new transaction.



#### REQUIRES_NEW

```
@Transactional (propogation = Propogation.REQUIRES_NEW)
```

- If we wants to isolate any Transaction from other ongoing Transactions.

- It will suspend the parent Transactions and create a new one for itself.


#### MANDATORY

```
@Transactional (propogation = Propogation.MANDATORY)
```

- It depends upon the Transaction process of Parent class or method.

- If Parent class doesn't have the Transaction Annotation, then it will throw exception.

- Ex - if you are doing some CRUD operation by utilizing the method of Repository on Service Layer, then its Parent (i.e., Controller Class) which is calling the Service Method should be annoted with `@Transactional`.





#### NESTED

```
@Transactional (propogation = Propogation.NESTED)
```

- If there is a Transaction alredy going on then it will execute the current Transaction in Nested way like pause the Parent Transaction and execute the child Transaction.

- If there is no Parent Transaction already going, then it will create a new Transaction for itself.





#### SUPPORTS

```
@Transactional (propogation = Propogation.SUPPORTS)
```

- If both the Parent and child methods (Like Controller and Service both are annotated and Controller is calling the Service one) are Annotated with this Annotation then the child Method acts as a support for Parent Annotation.






#### NOT_SUPPORTS

```
@Transactional (propogation = Propogation.NOT_SUPPORTS)
```
- If you wants to execute some Transaction only when other Transaction is not going on, then this will help.

- It suspends other Transactions and exectue the current.






#### NEVER

```
@Transactional (propogation = Propogation.NEVER)
```
- If you wants not to execute any Transaction if any Transaction already going on then we can use this one.