# Exception Handler and Controller Advice

Topic - 
1. Traditional Way of Handling Exceptions.
2. Exception Handler
3. Need of Controller Advise and Implementation

## 1. Traditional Way of Handling Exceptions.

In Traditional way, we create an Custom Exception class and then tries to throw all exceptions there.

Example - 

**Custom Exception Class** - 

```
public class MyProductException extends RuntimeException {

    public ProductException ( String message ) {
        super ( message ) ;
    }

}
```


And How we are using it our class is (like in Controller class)- 

```
@GetMapping("/api/getProductById/{productId}")
public ResponseEntity <Product> getBookById ( @PathVariable("productId") Integer productId ) {
    
    Product product = productService.findById(bookId).orElseThrow( () => new MyProductException("Product Not Found") );

}
```


Other way is - 

In Exception Handling we can define a separate ErrorResponse Class and can return it like below - 

```
@GetMapping("/api/getProductById/{productId}")
public ResponseEntity <?> getBookById ( @PathVariable("productId") Integer productId ) {
    
    try {
        Product product = productService.findById(bookId).orElseThrow( () => new MyProductException("Product Not Found") );
    }
    catch (MyProductException e) {
        ErrorResponse productNotFound = new ErrorResponse( e.message() ) ;
        return new ResponseEntity <ErrorResponse> (productNotFound, HttpStatus.NOT_FOUND);
    }

}
```





## 2. Exception Handler

- In this approach, we can define an extra method at the end (lets say HandleProductNotFoundException) and Annotate it with **@ExceptionHandler** so that everytime any exception comes, it will automatically sends a response.

Ex - 

```
@GetMapping("/api/getProductById/{productId}")
public ResponseEntity <Product> getBookById ( @PathVariable("productId") Integer productId ) {
    
    Product product = productService.findById(bookId).orElseThrow( () => new MyProductException("Product Not Found") );

}



@ExceptionHandler
public ResponseEntity <?> handleProductNotFoundException ( ProductNotFoundException exception ) {
    ErrorResponse productNotFound = new ErrorResponse (e.message() ) ;

    return new ResponseEntity <ErrorResponse> (productNotFound, Http.Status.NOT_FOUND) ; 
}
```
where ErrorResponse is another class we created to return Error Response.






## 3. Need of Controller Advise and Implementation

- In the above Exception Handler since we are defining the exception method on a particualr Controller file, this method wouldn't be available on other Controller files.

- Hence we have to create this method on all the controller files.

- So, Controller Advise helps us here.

- It allows to centralize our Exception Handler so that all controllers can utilize it.

- We can define a separate Class for Exception Handling an Annotate it with **ControllerAdvice**.

- It is a Class level annotation.

ex - 

```
@ControllerAdvise
public class GlobalExceptionHandler {

    @ExceptionHandler (ProductNotFoundException.class)
    public ResponseEntity <?> handleProductNotFoundException ( ProductNotFound exc ) {
        ErrorResponse errorResponse = new ErrorResponse (exc.message() ) ;

        return new ResponseEntity<ErrorResponse> (errorResponse, Http.Status.NOT_FOUND);
    }

}
```



We can also use **@RestControllerAdvise** which is **@ControllerAdvise** + **@ResponseBody**.