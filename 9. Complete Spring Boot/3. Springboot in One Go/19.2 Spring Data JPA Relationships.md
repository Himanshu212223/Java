# Spring Data JPA Relationships

Topics - 

1. Relationships and its Types
2. OneToOne
3. OneToMany
4. ManyToOne
5. ManyToMany



## 1. Relationships and its Types 

Relationships between entities represent how tables in the database are related to each other (via foreign keys).



## 2. OneToOne Mapping Unidirectional

- One entity is associated with exactly one other entity.

Example suppose we have Applicant Entity as below - 

```
@Entity
public class Applicant {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String name ;

    private String email ;

    private String phone ;
}
```


- Another Resume Entity looks like below - 

```
@Entity
public class Resume {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String content ;

    @OneToOne
    @JoinColumn(name = "applicantId", nullable = false)
    private Applicant applicant ;
}
```

- So, In Resume Class, the application will be stored as applicantId in the database and act as foreign key for the Relationship.



## 2. OneToOne Mapping Bidirectional

- Using this way, we can add the data of associated entity while adding the data of main entity.

- The Data of associated entity will be passed as an object in the json body from frontend.

Example suppose we have Applicant Entity as below - 

```
@Entity
public class Applicant {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String name ;

    private String email ;

    private String phone ;

    @OneToOne(mappedBy = "applicant", cascade = CascadeType.ALL)
    private Resume resume ;
}
```

- Defining the Cascase type will help to store the Resume enttity data first followed by the applicant data.


- Another Resume Entity looks like below - 

```
@Entity
public class Resume {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String content ;

    @OneToOne
    @JoinColumn(name = "applicantId", nullable = false)
    @JsonIgnore
    private Applicant applicant ;
}
```

- So, In Resume Class, the application will be stored as applicantId in the database and act as foreign key for the Relationship.

- **@JsonIgnore** will help to avoid any type of error while adding the data due to Bidirectional mapping.










## 3. OneToMany and ManyToOne

Since one Applicant can apply for many Applications,

Hence the Applicant Entity will look like below - 

```
@Entity
public class Applicant {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String name ;

    private String email ;

    private String phone ;

    @OneToOne(mappedBy = "applicant", cascade = CascadeType.ALL)
    private Resume resume ;

    @OneToMany (mappedBy = "applicant", cascade = CascadeType.ALL)
    private List<Application> applications = new ArrayList<>();
}
```


And the Application Entity will look like below - 

```
@Entity
public class Application {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String status ;
    private String position ;

    @ManyToOne
    @JoinColumn(name = "applicantId", nullable = false)
    @JsonIgnore
    private Applicant applicant ;
}
```





## 4. ManyToMany

- For Example, Many Applicant can apply for many jobs.

- Since we are mapping it through Many to Many, we need to have an extra table which stores which applicant is mapped with which Job.

Hence the Applicant Entity will look like below - 

```
@Entity
public class Applicant {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String name ;

    private String email ;

    private String phone ;

    @OneToOne(mappedBy = "applicant", cascade = CascadeType.ALL)
    private Resume resume ;

    @OneToMany (mappedBy = "applicant", cascade = CascadeType.ALL)
    private List<Application> applications = new ArrayList<>();

    @ManyToMany
    @JoinTable{
        name = "applicant_jobs",
        joinColumns = @JoinColumn(name = "applicantId"),
        inverseJoinColumns = @JoinColumn(name = "jobId")
    }
    private List<Job> jobs = new ArrayList<>();
    
}
```


And the Application Entity will look like below - 

```
@Entity
public class Job {
    @Id
    @GeneratedValue (strategy = GenerationType.AUTO)
    private Long id ;

    private String title ;
    private String description ;

    @ManyToMany (mappedBy = "jobs")
    @JsonIgnore
    private List<Applicant> applicants = new ArrayList<>() ;
}
```